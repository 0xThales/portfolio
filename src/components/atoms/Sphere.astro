---
// Import all tech icons
import astroIcon from "@assets/tech/astro.svg";
import bunIcon from "@assets/tech/bun.svg";
import figmaIcon from "@assets/tech/figma.svg";
import nextIcon from "@assets/tech/next.svg";
import nodeIcon from "@assets/tech/node.svg";
import postgresIcon from "@assets/tech/postgres.svg";
import reactIcon from "@assets/tech/react.svg";
import storybookIcon from "@assets/tech/storybook.svg";
import supabaseIcon from "@assets/tech/supabase.svg";
import tailwindIcon from "@assets/tech/tailwind.svg";
import tsIcon from "@assets/tech/ts.svg";

const icons = [
  astroIcon,
  bunIcon,
  figmaIcon,
  nextIcon,
  nodeIcon,
  postgresIcon,
  reactIcon,
  storybookIcon,
  supabaseIcon,
  tailwindIcon,
  tsIcon
];

// Extract src property from image metadata
const iconSrcs = icons.map(icon => icon.src);
---

<canvas id="canvas-container" class="w-[500px] h-[500px] absolute -bottom-20 z-10" data-icons={JSON.stringify(iconSrcs)}></canvas>

<script>
  import * as THREE from 'three';
  import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

  const canvas = document.getElementById('canvas-container') as HTMLCanvasElement | null;
  const icons: string[] = canvas ? JSON.parse(canvas.dataset.icons || '[]') : [];

  const setSphere = async () => {
    if (!canvas) return;

    const { clientWidth: w, clientHeight: h } = canvas;
    if (w === 0 || h === 0) {
      requestAnimationFrame(() => setSphere());
      return;
    }

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, w / h, 0.1, 1000);
    camera.position.z = 50;

    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(w, h, false);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.autoRotate = true;
    controls.autoRotateSpeed = 0.5;
    controls.addEventListener('start', () => canvas.style.cursor = 'var(--cursor-custom-grabbing)');
    controls.addEventListener('end', () => canvas.style.cursor = 'var(--cursor-custom-grab)');

    // Dark sphere
    const sphere = new THREE.Mesh(
      new THREE.SphereGeometry(20, 32, 32),
      new THREE.MeshPhysicalMaterial({
        color: 0x0a0a0a,
        transparent: true,
        opacity: 0.2,
        metalness: 0.1,
        roughness: 0.6,
        transmission: 0.75,
        thickness: 0.5,
        envMapIntensity: 0.8,
        clearcoat: 0.3,
        clearcoatRoughness: 0.4,
        reflectivity: 0.5,
      })
    );
    scene.add(sphere);

    // White star particles
    const particleCount = 200;
    const positions = new Float32Array(particleCount * 3);
    for (let i = 0; i < particleCount; i++) {
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.acos(Math.random() * 2 - 1);
      const r = 20.5 + Math.random() * 2;
      positions[i * 3] = r * Math.sin(phi) * Math.cos(theta);
      positions[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
      positions[i * 3 + 2] = r * Math.cos(phi);
    }
    const particleGeometry = new THREE.BufferGeometry();
    particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    const particles = new THREE.Points(
      particleGeometry,
      new THREE.PointsMaterial({
        color: 0xffffff,
        size: 0.15,
        transparent: true,
        opacity: 0.4,
        blending: THREE.AdditiveBlending
      })
    );
    scene.add(particles);

    // White outer glow
    const glowSphere = new THREE.Mesh(
      new THREE.SphereGeometry(25, 32, 32),
      new THREE.ShaderMaterial({
        uniforms: {
          glowColor: { value: new THREE.Color(0xffffff) },
          viewVector: { value: camera.position }
        },
        vertexShader: `
          uniform vec3 viewVector;
          varying float intensity;
          void main() {
            vec3 vNormal = normalize(normalMatrix * normal);
            vec3 vNormel = normalize(normalMatrix * viewVector);
            intensity = pow(0.7 - dot(vNormal, vNormel), 3.0);
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
        fragmentShader: `
          uniform vec3 glowColor;
          varying float intensity;
          void main() {
            vec3 glow = glowColor * intensity;
            gl_FragColor = vec4(glow, intensity * 0.5);
          }
        `,
        side: THREE.BackSide,
        blending: THREE.AdditiveBlending,
        transparent: true
      })
    );
    scene.add(glowSphere);

    // Dark inner glow
    const innerGlow = new THREE.Mesh(
      new THREE.SphereGeometry(19.5, 32, 32),
      new THREE.MeshBasicMaterial({
        color: 0x1e1b4b,
        transparent: true,
        opacity: 0.12,
        side: THREE.BackSide
      })
    );
    scene.add(innerGlow);

    // Lighting
    scene.add(new THREE.AmbientLight(0x1a1a2e, 0.3));
    const light1 = new THREE.DirectionalLight(0x8b8bb5, 0.6);
    light1.position.set(5, 5, 5);
    scene.add(light1);
    const light2 = new THREE.DirectionalLight(0x4f46e5, 0.3);
    light2.position.set(-5, -5, -5);
    scene.add(light2);
    const light3 = new THREE.DirectionalLight(0xccccff, 0.5);
    light3.position.set(0, 10, 0);
    scene.add(light3);

    // Tech icons on sphere surface
    const iconMeshes: THREE.Mesh[] = [];
    const goldenRatio = (1 + Math.sqrt(5)) / 2;
    const angleIncrement = Math.PI * 2 * goldenRatio;

    const loadIcon = (iconUrl: string): Promise<THREE.Texture | null> => {
      return new Promise((resolve) => {
        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.onload = () => {
          const canvas = document.createElement('canvas');
          canvas.width = canvas.height = 512;
          const ctx = canvas.getContext('2d', { alpha: true });
          if (ctx) {
            ctx.clearRect(0, 0, 512, 512);
            ctx.drawImage(img, 43, 43, 435, 435);
            const texture = new THREE.CanvasTexture(canvas);
            texture.minFilter = texture.magFilter = THREE.LinearFilter;
            resolve(texture);
          } else resolve(null);
        };
        img.onerror = () => resolve(null);
        img.src = iconUrl;
      });
    };

    const iconPromises = icons.map(async (iconUrl, i) => {
      const texture = await loadIcon(iconUrl);
      if (!texture) return null;

      const iconMesh = new THREE.Mesh(
        new THREE.PlaneGeometry(6, 6),
        new THREE.MeshBasicMaterial({
          map: texture,
          transparent: true,
          side: THREE.DoubleSide,
          depthWrite: false,
          alphaTest: 0.1
        })
      );

      const t = i / icons.length;
      const inclination = Math.acos(1 - 2 * t);
      const azimuth = angleIncrement * i;
      const x = 21 * Math.sin(inclination) * Math.cos(azimuth);
      const y = 21 * Math.sin(inclination) * Math.sin(azimuth);
      const z = 21 * Math.cos(inclination);

      iconMesh.position.set(x, y, z);
      iconMesh.lookAt(0, 0, 0);
      iconMesh.rotateY(Math.PI);

      return iconMesh;
    });

    const loadedMeshes = await Promise.all(iconPromises);
    loadedMeshes.forEach(mesh => {
      if (mesh) {
        scene.add(mesh);
        iconMeshes.push(mesh);
      }
    });

    // Icon hover effect
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let hoveredIcon: THREE.Mesh | null = null;

    canvas.addEventListener('mousemove', (event) => {
      const rect = canvas.getBoundingClientRect();
      mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(iconMeshes);

      if (hoveredIcon) hoveredIcon.scale.set(1, 1, 1);
      hoveredIcon = intersects.length > 0 ? intersects[0].object as THREE.Mesh : null;
      if (hoveredIcon) hoveredIcon.scale.multiplyScalar(1.15);
    });

    renderer.setAnimationLoop(() => {
      controls.update();
      renderer.render(scene, camera);
    });
  };

  setSphere();
</script>