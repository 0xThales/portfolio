<button id="pacman" class="group block max-sm:w-[60px] max-sm:h-[60px] w-[120px] h-[120px] rounded-full absolute max-sm:top-40 max-sm:-left-4 max-sm:translate-x-0 max-sm:translate-y-0 left-0 bottom-0 -translate-x-1/4 translate-y-1/4 bg-cover bg-center z-50 focus:outline-none" >
    <span id="pacman-text" class="font-family-vt323 group-hover:opacity-0 absolute -top-5 -right-10 text-primary-black max-sm:text-body-s text-body-l duration-200">Click me pls</span>
</button>

<script>
import { gameOn, knobState } from '../../store'
import pacmanImage from '../../assets/sprites/pacman.webp'
import pacmanRightImage from '../../assets/sprites/pacman-right.webp'
import pacmanLeftImage from '../../assets/sprites/pacman-left.webp'
import pacmanUpImage from '../../assets/sprites/pacman-up.webp'
import pacmanDownImage from '../../assets/sprites/pacman-down.webp'
import pacmanRightUpImage from '../../assets/sprites/pacman-right-up.webp'
import pacmanRightDownImage from '../../assets/sprites/pacman-right-down.webp'
import pacmanLeftUpImage from '../../assets/sprites/pacman-left-up.webp'
import pacmanLeftDownImage from '../../assets/sprites/pacman-left-down.webp'
import explosionImage from '../../assets/explosion.webp'
    
    const pacman = document.getElementById('pacman')
    const pacmanOriginalPosition = {
        x: 0,
        y: 0
    }

    const pacmanText = document.getElementById('pacman-text')
    pacman?.addEventListener('click', () => {
        if(gameOn.get()) return
        gameOn.set(true)
        pacmanText?.classList.add('hidden')
    })

    const SPEED = 10

    const pacmanPosition = {
        x: 0,
        y: 0
    }

    let lastSpriteState = '' // Track last sprite to prevent blinking
    let needsSpriteUpdate = false // Flag to check if sprite needs updating

    // Preload all sprites to prevent loading delays
    const spriteCache = new Map()
    const spriteAssets = {
        default: pacmanImage.src,
        right: pacmanRightImage.src,
        left: pacmanLeftImage.src,
        up: pacmanUpImage.src,
        down: pacmanDownImage.src,
        rightUp: pacmanRightUpImage.src,
        rightDown: pacmanRightDownImage.src,
        leftUp: pacmanLeftUpImage.src,
        leftDown: pacmanLeftDownImage.src,
        explosion: explosionImage.src
    }

    // Preload images using imported assets
    Object.values(spriteAssets).forEach(assetUrl => {
        const img = new Image()
        img.src = assetUrl
        spriteCache.set(assetUrl, img)
    })

    const keysState = {
        left: false,
        right: false,
        up: false,
        down: false
    }

    let animationFrameId: number | null = null
    let lastTime: number | null = null
    let keydownListener: ((e: KeyboardEvent) => void) | null = null
    let keyupListener: ((e: KeyboardEvent) => void) | null = null

    gameOn.subscribe(value => {
        if(!pacman) return
        
        if(value) {
            // Game starting - initialize everything
            pacman.style.rotate = '0deg'
            pacmanPosition.x = 0
            pacmanPosition.y = 0
            lastSpriteState = ''
            
            // Reset all key states
            keysState.left = false
            keysState.right = false
            keysState.up = false
            keysState.down = false

            const EXPLOSION_RADIUS = 20

            // Check pacman position against the viewport using actual on-screen bounds
            const checkPacmanPosition = () => {
                const rect = pacman.getBoundingClientRect()
                if(rect.right < 0) pacmanPosition.x = window.innerWidth - pacman.clientWidth
                if(rect.left > window.innerWidth) pacmanPosition.x = 0
                if(rect.bottom < 0) pacmanPosition.y = window.innerHeight - pacman.clientHeight
                if(rect.top > window.innerHeight) pacmanPosition.y = -(window.innerHeight - pacman.clientHeight)
            }

            const checkCollisiions = () => {
                if(!pacman) return

                const elements = Array.from(document.querySelectorAll<HTMLElement>('.explosion-letter'))

                const pacmanRect = pacman.getBoundingClientRect()

                const isOverlapping = (a: DOMRect, b: DOMRect) => {
                    return !(a.right <= b.left || a.left >= b.right || a.bottom <= b.top || a.top >= b.bottom)
                }

                elements.forEach((element) => {
                    const elementRect = element.getBoundingClientRect()
                    if(isOverlapping(pacmanRect, elementRect)) {
                        const explosionImg = new Image()
                        explosionImg.classList.add('transition-opacity', 'duration-1000')
                        explosionImg.src = spriteAssets.explosion
                        // Position relative to viewport rects
                        explosionImg.style.position = 'fixed'
                        explosionImg.style.top = `${elementRect.top + elementRect.height / 2 - EXPLOSION_RADIUS}px`
                        explosionImg.style.left = `${elementRect.left + elementRect.width / 2 - EXPLOSION_RADIUS}px`
                        // Inline dimensions so Tailwind JIT doesn't strip dynamic classes
                        explosionImg.style.width = `${EXPLOSION_RADIUS * 2}px`
                        explosionImg.style.height = `${EXPLOSION_RADIUS * 2}px`
                        explosionImg.style.opacity = '1'
                        document.body.appendChild(explosionImg)
                        requestAnimationFrame(() => { explosionImg.style.opacity = '0' })
                        setTimeout(() => { explosionImg.remove() }, 1000)

                        element.classList.add('opacity-0', 'exploded')
                        element.classList.remove('explosion-letter')
                    }
                })
            }

            keydownListener = (e: KeyboardEvent) => {
                const {key} = e
                switch (key) {
                    case 'd':
                        if(!keysState.right) {
                            keysState.right = true
                            needsSpriteUpdate = true
                        }
                        break;
                    case 'a':
                        if(!keysState.left) {
                            keysState.left = true
                            needsSpriteUpdate = true
                        }
                        break;
                    case 'w':
                        if(!keysState.up) {
                            keysState.up = true
                            needsSpriteUpdate = true
                        }
                        break;
                    case 's':
                        if(!keysState.down) {
                            keysState.down = true
                            needsSpriteUpdate = true
                        }
                        break;
                }
            }

            keyupListener = (e: KeyboardEvent) => {
                const {key} = e
                switch (key) {
                    case 'd':
                        if(keysState.right) {
                            keysState.right = false
                            needsSpriteUpdate = true
                        }
                        break;
                    case 'a':
                        if(keysState.left) {
                            keysState.left = false
                            needsSpriteUpdate = true
                        }
                        break;
                    case 'w':
                        if(keysState.up) {
                            keysState.up = false
                            needsSpriteUpdate = true
                        }
                        break;
                    case 's':
                        if(keysState.down) {
                            keysState.down = false
                            needsSpriteUpdate = true
                        }
                        break;
                }
            }

            const setPacmanSprite = () => {
                let newSprite = ''

                // Combine keyboard and knob states
                const knob = knobState.get()
                const right = keysState.right || knob.right
                const left = keysState.left || knob.left
                const up = keysState.up || knob.up
                const down = keysState.down || knob.down

                // Determine which sprite should be used
                if(right && up) {
                    newSprite = spriteAssets.rightUp
                }
                else if(right && down) {
                    newSprite = spriteAssets.rightDown
                }
                else if(left && up) {
                    newSprite = spriteAssets.leftUp
                }
                else if(left && down) {
                    newSprite = spriteAssets.leftDown
                }
                // Single directions (only if no diagonal)
                else if(right) {
                    newSprite = spriteAssets.right
                }
                else if(left) {
                    newSprite = spriteAssets.left
                }
                else if(up) {
                    newSprite = spriteAssets.up
                }
                else if(down) {
                    newSprite = spriteAssets.down
                }

                // Only update sprite if it actually changed AND sprite is preloaded
                if(newSprite && newSprite !== lastSpriteState && spriteCache.has(newSprite)) {
                    pacman.style.backgroundImage = `url('${newSprite}')`
                    lastSpriteState = newSprite
                    needsSpriteUpdate = false
                }
            }

            const setPacmanPosition = (frameScale: number = 1) => {
                const knob = knobState.get()

                if(keysState.right || knob.right) {
                    pacmanPosition.x += SPEED * frameScale
                }
                if(keysState.left || knob.left) {
                    pacmanPosition.x -= SPEED * frameScale
                }
                if(keysState.up || knob.up) {
                    pacmanPosition.y -= SPEED * frameScale
                }
                if(keysState.down || knob.down) {
                    pacmanPosition.y += SPEED * frameScale
                }
            }

            lastTime = null
            const loop = (time: number) => {
                // Always check sprite state (for both keyboard and knob changes)
                setPacmanSprite()

                const previousTime = lastTime ?? time
                const delta = time - previousTime
                lastTime = time
                const frameScale = delta / (1000 / 60)

                setPacmanPosition(frameScale)
                checkPacmanPosition()
                checkCollisiions()
                // Apply translation (no more rotation needed)
                pacman.style.transform = `translateX(${pacmanPosition.x}px) translateY(${pacmanPosition.y}px)`
                animationFrameId = requestAnimationFrame(loop)
            }
            animationFrameId = requestAnimationFrame(loop)

            document.addEventListener('keydown', keydownListener)
            document.addEventListener('keyup', keyupListener)
        } else {
            // Game ending - cleanup everything
            if(keydownListener) {
                document.removeEventListener('keydown', keydownListener)
                keydownListener = null
            }
            if(keyupListener) {
                document.removeEventListener('keyup', keyupListener)
                keyupListener = null
            }
            if(animationFrameId !== null) {
                cancelAnimationFrame(animationFrameId)
                animationFrameId = null
            }
            lastTime = null
            
            // Reset Pacman to original state
            pacmanPosition.x = pacmanOriginalPosition.x 
            pacmanPosition.y = pacmanOriginalPosition.y 
            lastSpriteState = ''
            
            // Reset to original sprite and position
            pacman.style.backgroundImage = `url('${spriteAssets.rightUp}')`
            pacman.style.transform = `translateX(${pacmanPosition.x}px) translateY(${pacmanPosition.y}px)`
            
            keysState.left = false
            keysState.right = false
            keysState.up = false
            keysState.down = false
            
            pacmanText?.classList.remove('hidden')
            const explodedElements = document.querySelectorAll<HTMLElement>('.exploded')
            explodedElements.forEach(element => {
                element.classList.remove('opacity-0', 'exploded')
                element.classList.add('explosion-letter')
            })
        }
    })

    // Set initial sprite based on screen size
    const setInitialSprite = () => {
        if(!pacman) return
        const isMobile = window.innerWidth < 640 // sm breakpoint
        const initialSprite = isMobile ? spriteAssets.right : spriteAssets.rightUp
        pacman.style.backgroundImage = `url('${initialSprite}')`
    }

    // Set initial sprite on load
    setInitialSprite()

    // Update sprite on resize
    window.addEventListener('resize', setInitialSprite)

</script>